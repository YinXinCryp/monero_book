#  5 深入Monero和密码学 

在计算机诞生很久以前，数学和密码一直是通信和信息交换的中心。自从凯撒时代以来，简单的密码就已经出现了，现代密码学诞生于世界大战期间，用于加密重要和机密的信息。最初，政府和军方资助密码学研究以求找到保护国家机密的协议。

现在，密码学不再局限于间谍和军队；它是互联网时代通信和安全的中坚力量，受到全球来自学术界和工业界研究者的广泛研究。

今天，密码学是一个无处不在的幕后工具，它使安全、管理、通信和许多改善我们日常生活的连接成为可能。例如，考虑一下安全套接字层(SSL，不赞成使用TSL)的发明，它基于对内容进行密码签名。医院、银行、政府和企业都使用密码保护您的数据。

本章讨论如何将密码工具应用到去中心化的金融数据库中，从而催生出密码货币，尤其是Monero。

## 5.1 数学基础

下面简要介绍密码学中核心的几个数学原理。

### 5.1.1 **欧几里德除法** **(A/B)** 

将任意数字A除以另一个B（记为A/B或A÷B）返回一个答案，该答案可以写成带余数的商，也可以单独写成十进制。

通常:

A/B = q 余数 r

例如:

12/4=3，余数为0，可以用十进制形式记为3.0

13/4=3，余数为1，可用十进制形式记为3.25

27/5=5，余数为2，可以用十进制形式记为5.4

### 5.1.2 **素数**

素数是除“1”和它本身之外，不能被其他任何整数整除的数。例如：

20不是素数，因为它可以被2, 4, 5和10整除，然后得到整数。

例如. 20 ÷ 4 = 5

 \- 或 - 

20 ÷ 10 = 2 

7是素数，因为任何整数整除7都不会得到整数。

例如. 7 ÷ 3 = 2.3333 

一些素数的例子包括3, 5, 7, 11, 13, 97, 223, 997, 3413, 4421, 17837, 145601, 428567, 1171967, 甚至更大的数字像20747222467734852078216952221076085874809964747 21117292752992589912196684750549658310084416732550077 ，或双素数2,996,863,034,895×2^1,290,000±1，每个数超过350,000位!

### 5.1.3 **模运算** 

模运算是指数字折回到特定整数内。最常见的例子是12小时制，如果你在晚上11点之后熬夜5小时，你就不会见到下午16点的时钟！ 相反，在午夜，时间折回到零（所以在晚上11点过后5小时是第二天凌晨4点）。

给出任意两个正数，A（被除数）和B（除数），

A模B = A / B的余数r。

在时钟例子中，晚上11点后再过熬夜5小时可以表示为：

（11:00 PM + 5小时）mod 12 = ... = 16:00 mod 12

= 4:00（AM）

### 5.1.4 **整数表示** 

整数可以用许多不同的编码来表示，其中一些在计算机科学中经常遇到。

大多数人都非常熟悉以10为基数的“十进制”系统，它代表使用10个字符的数字：

0,1,2,3,4,5,6,7,8,9. 

对于基数为16的集合，“十六进制”编码增加了6个额外字符：0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f。

用十进制记为11719682的整数可以表示为用16进制的B2D402。 注意，更大的字符集需要较少的数字（较短的字符串）来表示相同的数字。

计算机按二进制“思考”，仅使用字符“0”和“1”。这称为二进制，数字11719682（10进制）将表示为101100101101010000000010。

Monero 基于58进制打印最终地址和密钥，它使用阿拉伯数字和大多数拉丁字符集（大写和小写）。 它类似于另一种称为Base64的方案，但是它已被修改以避免在打印时看起来有歧义的数字和字母。Monero使用这种格式，完全是为了方便人类用户，这些用户通常必须手动读取或抄写长地址。

58进制数是：

123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz

注意：零（0）和字母I（大写的i），O（大写的o）和l（小写的L）在这个Base58字母表中不存在，因为它们彼此的二义性。

### 5.1.5椭圆曲线

#### 5.1.5.1 **一般介绍** 

椭圆曲线定义为满足方程的二维(x, y)点集:

y2=x3+ax+b.

例如，固定系数a=2，b=3，等式变为

y2=x3+2x+3.

很多对点满足等式，如:

x = 3和y = 6

x = 3 和 y = -6

 x = -1 和y = 0.

#### 5.1.5.2Ed25519 Twisted Edwards 

Monero使用一条特殊的Twisted Edwards 椭圆曲线进行密码运算，Ed25519, 它是Montgomery曲线Curve25519的双有理等价。 Ed25519曲线可以代数表示为

\- x2 + y2 = 1 − (121665/121666) x2*y2. 

回想一下我们一般的椭圆曲线方程，这个Twisted Edwards是一个特例，它使用的参数是:

a = -1 和 b = 121665/121666. 

最近，NIST背书的PRNG（Pseudo-random Number Generator算法）存在缺陷变得很显然，并且包含潜在的后门。 由于NIST4标准算法最近出现了问题，因此选择Twisted Edwards曲线来解决密码学界所关注的许多问题。

从更广泛的角度来看，NIST选择的曲线也得到了NSA的秘密支持。密码学家和密码货币社区对这些支持持怀疑态度，因为在过去的事件中，NSA利用它们对NIST的权力削弱了后者提出的算法。

Twisted Edwards曲线Ed25519不受任何专利的约束，其背后的团队开发并改进了基本的密码算法，并考虑了效率。目前认为该曲线是安全的。

#### 5.1.5.3 **椭圆运算** 

椭圆曲线点的加法和标量乘法是椭圆曲线密码方案的基本操作。在深入Monero的计算机制之前，对这些概念有一个基本的了解是有帮助的。

椭圆曲线点的加法运算不同于一般的加法运算。要对椭圆曲线上的两个点同时做加法，必须找到这两个点之间的直线，然后找到曲线与该线相交的点。然后这个点关于x轴上对称点为最终点。

当向自身相加一个点时，称为倍点运算(point doubling)，您必须找到起点的切线，找到切线与曲线的交点。然后这个点在x轴上对称点为最终点。

标量乘法(scalar multiplication)使用曲线上的一个点和整数。要用整数S乘以一个点P，该点和自身相加S次。很多密码方案，例如Monero采用的方案，使用了椭圆曲线上的一个公共基点作为生成元点来生成对应私钥的公钥。

当曲线生成元点多次和自身相加时，生成的点不能用于确定发生了多少次运算。这个问题常称为椭圆曲线离散对数问题。这种标量乘法被认为是一个单向函数，因为求逆运算非常困难。

## 5.2 密码学基础知识

Monero由于其独特的面向隐私的密码特性而成为领先的安全的和不可追踪的密码货币，本章将对此进行更深入地探讨。由于密码学的数学性质，这是本书中比较技术性的章节之一。更复杂的技术是建立在称为密码原语的简单原理之上的。

密码原语是一种算法，可以作为密码协议的组成部分。Monero使用很多的密码原语，各有用途，其中一些原语我们在第3章和第4章概念性地介绍过它们。Monero主推的隐私和（抗ASIC）工作量证明方法需要比许多其他密码货币使用更复杂的密码工具。

### 5.2.1 对称和非对称密码学

对于加密数据，可以根据使用的密钥类型将密码算法刻画为对称密码或非对称密码。

对称加密要求参与者共享一个秘密，例如您使用口令“hunter2”加密消息，而接收方使用口令“hunter2”对其解密。要想以这种方式进行通信，双方必须事先就共享(对称)秘密达成一致。这一客观存在的问题限制了对称加密在许多应用程序中的实用性。

非对称加密允许双方安全地交互，而无需共享特定的密钥。这种加密技术被编织到互联网安全框架、端到端的即时通信软件和密码货币中。

比特币使用有两个密钥的非对称加密:

- 私钥(private key)-用于签署交易和解密数据
- 公钥(public key)-用于验签和加密数据

Monero的更复杂的密码框架需要四个密钥:

- 公开可视秘钥 （public view key）——用于验证地址的有效性
- 私有可视密钥（private view key）——用于查看诸如余额，交易费用和交易金额(视图密钥不能创建或签署交易)等数据
- 公开花费密钥（public spend key）——用于验证交易的另一个公钥
- 私有花费密钥（private spend key）-用于签署交易，例如，发送moneroj

您的公开Monero地址是一对公钥的直接表示，而比特币(和竞争币)使用其单个公钥的散列作为地址。EdDSA密钥(私钥和公钥)是长度是256位，或64个十六进制字符。不是每个256位整数都是有效的EdDSA标量(私钥)；它必须小于Ed25519函数章节中方程所描述的“曲线阶”。

### 5.2.2 哈希

第4章讨论了哈希的概念，以及它的使用范围，从确定数据保真度到在工作证明中分发奖励。示例哈希在第4章末尾的密码学部分。

选择一个好的哈希算法以安全的方式生成地址和密钥至关重要。如果两个不同的输入产生相同的哈希输出，则称为碰撞(collision)。由于哈希算法具有有效的唯一性，因此哈希通常用作区块链系统中的标识符。此外，种子生成过程中的碰撞会导致多个人拥有相同的密钥和地址；显然这将是非常有问题的！

Monero使用CryptoNight PoW系统，该系统使用一种特殊的CryptoNote哈希算法，该算法建立在Keccak哈希的基础上。Keccak算法在NIST竞赛中获胜，被命名为SHA3，由非NSA的工程师设计。Monero的交易和区块哈希都使用Keccak-256哈希函数，输出长度32字节。

### 5.2.3 Monero **伪随机数生成** **(PRNG)** 

当用户和计算机创建新密钥时，他们找到的新密钥不能被其他人猜到,这一点很关键。这实际上是一个非常困难的任务，因为硬件和软件的设计都是为了支持可复现性。如果计算机以一种可预测的方式生成随机性，那么输出可能表面上是随机的，但在某种程度上更容易猜测。

例如，考虑一个PRNG，它只是将当前时间的数字打乱，生成一个4位数字的密钥。所以在“10:34”，它可能输出“0413”或“1403”或“0134”…如果您想输出密钥保密，这将是一个糟糕的方法，原因如下:

如果攻击者知道您在上午12点45分左右开始工作时使用了密钥，那么他就会知道出现了数字“1”和“2”，从而将选择范围缩小到明显更少的选项。

一天中没有三个数字“9”的HH:MM这种时间。事实上，不存在这样一个时间，它的任意3个数字是选自{6，7，8，9}，因为17:89 h，18:78 h等都是不可能的时间。这条规则消除了许多4位数的组合，让攻击者从一个小得多的池中猜测。

上述基于时钟的随机数生成器是极其糟糕的，因为使用某天的时间作为初始种子是可预测的。对于攻击者而言，初始种子应该更难猜中。好的随机数生成器引入大量的熵以另其输出变得不可预测。简单打乱4个数并没有引入更多的熵，这是另一个致使我们上述的PRNG不安全的原因。

在生成钱包时，用户的操作系统提供了初始的种子/熵源。Monero反复应用Keccak哈希函数来产生一个不可预测和不可再现的输出。每轮哈希产生一个输出，该输出用作下次哈希的输入。