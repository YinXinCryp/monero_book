#  5 深入Monero和密码学 

在计算机诞生很久以前，数学和密码一直是通信和信息交换的中心。自从凯撒时代以来，简单的密码就已经出现了，现代密码学诞生于世界大战期间，用于加密重要和机密的信息。最初，政府和军方资助密码学研究以求找到保护国家机密的协议。

现在，密码学不再局限于间谍和军队；它是互联网时代通信和安全的中坚力量，受到全球来自学术界和工业界研究者的广泛研究。

今天，密码学是一个无处不在的幕后工具，它使安全、管理、通信和许多改善我们日常生活的连接成为可能。例如，考虑一下安全套接字层(SSL，不赞成使用TSL)的发明，它基于对内容进行密码签名。医院、银行、政府和企业都使用密码保护您的数据。

本章讨论如何将密码工具应用到去中心化的金融数据库中，从而催生出密码货币，尤其是Monero。

## 5.1 数学基础

下面简要介绍密码学中核心的几个数学原理。

### 5.1.1 **欧几里德除法** **(A/B)** 

将任意数字A除以另一个B（记为A/B或A÷B）返回一个答案，该答案可以写成带余数的商，也可以单独写成十进制。

通常:

A/B = q 余数 r

例如:

12/4=3，余数为0，可以用十进制形式记为3.0

13/4=3，余数为1，可用十进制形式记为3.25

27/5=5，余数为2，可以用十进制形式记为5.4

### 5.1.2 **素数**

素数是除“1”和它本身之外，不能被其他任何整数整除的数。例如：

20不是素数，因为它可以被2, 4, 5和10整除，然后得到整数。

例如. 20 ÷ 4 = 5

 \- 或 - 

20 ÷ 10 = 2 

7是素数，因为任何整数整除7都不会得到整数。

例如. 7 ÷ 3 = 2.3333 

一些素数的例子包括3, 5, 7, 11, 13, 97, 223, 997, 3413, 4421, 17837, 145601, 428567, 1171967, 甚至更大的数字像20747222467734852078216952221076085874809964747 21117292752992589912196684750549658310084416732550077 ，或双素数2,996,863,034,895×2^1,290,000±1，每个数超过350,000位!

### 5.1.3 **模运算** 

模运算是指数字折回到特定整数内。最常见的例子是12小时制，如果你在晚上11点之后熬夜5小时，你就不会见到下午16点的时钟！ 相反，在午夜，时间折回到零（所以在晚上11点过后5小时是第二天凌晨4点）。

给出任意两个正数，A（被除数）和B（除数），

A模B = A / B的余数r。

在时钟例子中，晚上11点后再过熬夜5小时可以表示为：

（11:00 PM + 5小时）mod 12 = ... = 16:00 mod 12

= 4:00（AM）

### 5.1.4 **整数表示** 

整数可以用许多不同的编码来表示，其中一些在计算机科学中经常遇到。

大多数人都非常熟悉以10为基数的“十进制”系统，它代表使用10个字符的数字：

0,1,2,3,4,5,6,7,8,9. 

对于基数为16的集合，“十六进制”编码增加了6个额外字符：0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f。

用十进制记为11719682的整数可以表示为用16进制的B2D402。 注意，更大的字符集需要较少的数字（较短的字符串）来表示相同的数字。

计算机按二进制“思考”，仅使用字符“0”和“1”。这称为二进制，数字11719682（10进制）将表示为101100101101010000000010。

Monero 基于58进制打印最终地址和密钥，它使用阿拉伯数字和大多数拉丁字符集（大写和小写）。 它类似于另一种称为Base64的方案，但是它已被修改以避免在打印时看起来有歧义的数字和字母。Monero使用这种格式，完全是为了方便人类用户，这些用户通常必须手动读取或抄写长地址。

58进制数是：

123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz

注意：零（0）和字母I（大写的i），O（大写的o）和l（小写的L）在这个Base58字母表中不存在，因为它们彼此的二义性。

### 5.1.5椭圆曲线

#### 5.1.5.1 **一般介绍** 

椭圆曲线定义为满足方程的二维(x, y)点集:

y2=x3+ax+b.

例如，固定系数a=2，b=3，等式变为

y2=x3+2x+3.

很多对点满足等式，如:

x = 3和y = 6

x = 3 和 y = -6

 x = -1 和y = 0.

#### 5.1.5.2Ed25519 Twisted Edwards 

Monero使用一条特殊的Twisted Edwards 椭圆曲线进行密码运算，Ed25519, 它是Montgomery曲线Curve25519的双有理等价。 Ed25519曲线可以代数表示为

\- x2 + y2 = 1 − (121665/121666) x2*y2. 

回想一下我们一般的椭圆曲线方程，这个Twisted Edwards是一个特例，它使用的参数是:

a = -1 和 b = 121665/121666. 

最近，NIST背书的PRNG（Pseudo-random Number Generator算法）存在缺陷变得很显然，并且包含潜在的后门。 由于NIST4标准算法最近出现了问题，因此选择Twisted Edwards曲线来解决密码学界所关注的许多问题。

从更广泛的角度来看，NIST选择的曲线也得到了NSA的秘密支持。密码学家和密码货币社区对这些支持持怀疑态度，因为在过去的事件中，NSA利用它们对NIST的权力削弱了后者提出的算法。

Twisted Edwards曲线Ed25519不受任何专利的约束，其背后的团队开发并改进了基本的密码算法，并考虑了效率。目前认为该曲线是安全的。

#### 5.1.5.3 **椭圆运算** 

椭圆曲线点的加法和标量乘法是椭圆曲线密码方案的基本操作。在深入Monero的计算机制之前，对这些概念有一个基本的了解是有帮助的。

椭圆曲线点的加法运算不同于一般的加法运算。要对椭圆曲线上的两个点同时做加法，必须找到这两个点之间的直线，然后找到曲线与该线相交的点。然后这个点关于x轴上对称点为最终点。

当向自身相加一个点时，称为倍点运算(point doubling)，您必须找到起点的切线，找到切线与曲线的交点。然后这个点在x轴上对称点为最终点。

标量乘法(scalar multiplication)使用曲线上的一个点和整数。要用整数S乘以一个点P，该点和自身相加S次。很多密码方案，例如Monero采用的方案，使用了椭圆曲线上的一个公共基点作为生成元点来生成对应私钥的公钥。

当曲线生成元点多次和自身相加时，生成的点不能用于确定发生了多少次运算。这个问题常称为椭圆曲线离散对数问题。这种标量乘法被认为是一个单向函数，因为求逆运算非常困难。

## 5.2 密码学基础知识

Monero由于其独特的面向隐私的密码特性而成为领先的安全的和不可追踪的密码货币，本章将对此进行更深入地探讨。由于密码学的数学性质，这是本书中比较技术性的章节之一。更复杂的技术是建立在称为密码原语的简单原理之上的。

密码原语是一种算法，可以作为密码协议的组成部分。Monero使用很多的密码原语，各有用途，其中一些原语我们在第3章和第4章概念性地介绍过它们。Monero主推的隐私和（抗ASIC）工作量证明方法需要比许多其他密码货币使用更复杂的密码工具。

### 5.2.1 对称和非对称密码学

对于加密数据，可以根据使用的密钥类型将密码算法刻画为对称密码或非对称密码。

对称加密要求参与者共享一个秘密，例如您使用口令“hunter2”加密消息，而接收方使用口令“hunter2”对其解密。要想以这种方式进行通信，双方必须事先就共享(对称)秘密达成一致。这一客观存在的问题限制了对称加密在许多应用程序中的实用性。

非对称加密允许双方安全地交互，而无需共享特定的密钥。这种加密技术被编织到互联网安全框架、端到端的即时通信软件和密码货币中。

比特币使用有两个密钥的非对称加密:

- 私钥(private key)-用于签署交易和解密数据
- 公钥(public key)-用于验签和加密数据

Monero的更复杂的密码框架需要四个密钥:

- 公开可视秘钥 （public view key）——用于验证地址的有效性
- 私有可视密钥（private view key）——用于查看诸如余额，交易费用和交易金额(视图密钥不能创建或签署交易)等数据
- 公开花费密钥（public spend key）——用于验证交易的另一个公钥
- 私有花费密钥（private spend key）-用于签署交易，例如，发送moneroj

您的公开Monero地址是一对公钥的直接表示，而比特币(和竞争币)使用其单个公钥的散列作为地址。EdDSA密钥(私钥和公钥)是长度是256位，或64个十六进制字符。不是每个256位整数都是有效的EdDSA标量(私钥)；它必须小于Ed25519函数章节中方程所描述的“曲线阶”。

### 5.2.2 哈希

第4章讨论了哈希的概念，以及它的使用范围，从确定数据保真度到在工作证明中分发奖励。示例哈希在第4章末尾的密码学部分。

选择一个好的哈希算法以安全的方式生成地址和密钥至关重要。如果两个不同的输入产生相同的哈希输出，则称为碰撞(collision)。由于哈希算法具有有效的唯一性，因此哈希通常用作区块链系统中的标识符。此外，种子生成过程中的碰撞会导致多个人拥有相同的密钥和地址；显然这将是非常有问题的！

Monero使用CryptoNight PoW系统，该系统使用一种特殊的CryptoNote哈希算法，该算法建立在Keccak哈希的基础上。Keccak算法在NIST竞赛中获胜，被命名为SHA3，由非NSA的工程师设计。Monero的交易和区块哈希都使用Keccak-256哈希函数，输出长度32字节。

### 5.2.3 Monero **伪随机数生成** **(PRNG)** 

当用户和计算机创建新密钥时，他们找到的新密钥不能被其他人猜到,这一点很关键。这实际上是一个非常困难的任务，因为硬件和软件的设计都是为了支持可复现性。如果计算机以一种可预测的方式生成随机性，那么输出可能表面上是随机的，但在某种程度上更容易猜测。

例如，考虑一个PRNG，它只是将当前时间的数字打乱，生成一个4位数字的密钥。所以在“10:34”，它可能输出“0413”或“1403”或“0134”…如果您想输出密钥保密，这将是一个糟糕的方法，原因如下:

如果攻击者知道您在上午12点45分左右开始工作时使用了密钥，那么他就会知道出现了数字“1”和“2”，从而将选择范围缩小到明显更少的选项。

一天中没有三个数字“9”的HH:MM这种时间。事实上，不存在这样一个时间，它的任意3个数字是选自{6，7，8，9}，因为17:89 h，18:78 h等都是不可能的时间。这条规则消除了许多4位数的组合，让攻击者从一个小得多的池中猜测。

上述基于时钟的随机数生成器是极其糟糕的，因为使用某天的时间作为初始种子是可预测的。对于攻击者而言，初始种子应该更难猜中。好的随机数生成器引入大量的熵以另其输出变得不可预测。简单打乱4个数并没有引入更多的熵，这是另一个致使我们上述的PRNG不安全的原因。

在生成钱包时，用户的操作系统提供了初始的种子/熵源。Monero反复应用Keccak哈希函数来产生一个不可预测和不可再现的输出。每轮哈希产生一个输出，该输出用作下次哈希的输入。

## 5.3 Monero 密钥和地址 

### 5.3.1 选择种子

在第二章我们提到了钱包的核心：种子。您的钱包产生这个种子，它用来导出你的密钥，并访问/花费您的资金。在那部分的概述中，我们只考虑了25个字的种子助记符。

在背后，种子是一个确定的256位整数，用来导出密钥和地址，例如：

112699108505435943726051051450940377552177626778909564691673845134467691053980

这些通常表示为64个16进制数，例如：

f9296f587419f1cdede67de160fca14d1069ecaa4c52f012af031eeA09ee039c 

（对于助记符样式的密钥，种子的这种表示实际上只有私有花费密钥！）

写下上述任何一种密钥样式都会非常困难，而且大多数人都会倾向犯下至少一个错误。转换为种子助记符短语是唯一包含的面向人类可解释性和可用性的另一步。 助记符短语实质上将上述256位数转换为24个（24字）1626进制“数字”（因为种子字典中有1626个字节）。这样表示长的种子字符串更容易阅读：

lamb hexagon aces acquire twang bluntly argue when unafraid awning academy nail threaten sailor palace selfish cadets click sickness juggled border thumbs remedy ridges border 

当您的钱包出现24字的种子时，它会添加第25个字作为校验和(checksum)，以便后续检测拼写错误或错误。 Monero的助记符方法以最小的4：3的比例编码。 换句话说，四个字节创建三个字，加上一个校验和字; 八个字节创建六个字，加上一个校验和字; 等等。

私有可视密钥是通过使用Keccak-256对种子进行哈希而生成的，生成第二个256位整数，然后将其发送到名为sc_reduce32的函数，以确保它与椭圆曲线兼容。 此方法创建的种子将始终是有效的标量，因为它们首先被发送到sc_reduce32。

### **5.3.2** **密钥推导** 

#### **5.3.2.1** **密钥** 

上面描述的Monero种子实际上是您的秘密花费密钥(secret spend key)，从秘密花费密钥中可以导出所有其他密钥。 秘密可视密钥(secret view key)是您的秘密花费密钥的简化散列，可转换为ed25519曲线的一个有效标量。

这两个私钥乘以生成元点会产生钱包的两个公钥（公开花费（public spend）和公开可视（public view）密钥）。 这种用于推导出密钥的方法被称为确定性方法。

#### **5.3.2.2** **只可查看钱包** 

您可以通过使用您的秘密可视密钥设置钱包，而不是秘密花费密钥，授予对Monero帐户的只可查看(view-only)访问权限。 这些只可查看的钱包可以查看所有流入(进来)的交易，但无法花费moneroj或查看流出的交易。

这里有几种情况可以在没有发送访问权限的情况下检查流入的交易。 例如，拥有冷钱包的个人可以使用可视密钥来检查资金是否到账，同时保障他们的秘密花费密钥安全。同样，开发人员可以构建检测和响应收款的系统，而无需移动这些资金。

这个功能对慈善机构特别有价值，慈善机构可以分享他们的可视密钥来确保捐赠的透明度和问责制。 如果您向公开地址捐款，您可以使用可视密钥来验证慈善机构是否收到了您的资金。

例如，考虑主要的Monero捐赠地址：

44AFFq5kSiGBoZ4NMDwYtN18obc8AemS33DBLWs3H7otXft3XjrpDtQGv7SqSsaBYBb98uNbr2VBBEt7f2wfn3RVGQBEP3A. 

由于隐地址(stealth addresses)阻止在区块链上记录或搜索公开地址，社区还会公布可视密钥（f359631075708155cc3d92a32b75a7d02a5d-cf27756707b47a2b31b21c389501），以便公众可以查看捐赠活动。

由于任何拥有可视密钥的人都可以看到钱包收到的总金额，因此一个已经有100 XMR的透明慈善机构无法转移90 XMR并声称他们只收到了10个XMR。 此功能对于必须达到某个捐赠阈值的众筹情况尤其有用。

我们无法从只可查看钱包中看到流出交易是一项功能，而不是一个问题！如果流出交易是公开的，钱包将显示其何时被花费。 这将是非常有问题的，因为环签名依赖于花费状态的二义性(不确定性)。 假设一个慈善机构披露了何时花出一项输出; 所有出现在未来(和以前)的环签名都可以被认为是诱饵。 因此，不暴露流出交易对于维护整体网络隐私的完整性是必要的。

### **5.3.3** **地址生成** 

Monero钱包的标准地址由两个公钥（公开花费密钥+公开可视密钥）组成，本节的最后部分会导出地址。 它还包含一个校验和，一个网络字节（network byte），用于标识网络和地址类型。

#### **5.3.3.1** **网络字节** 

网络字节用于区分各种密码货币和网络。 例如，CryptoNote coins在文件src / CryptoNote_config.h中指定适当的值。例如：

uint64_t const CRYPTONOTE_PUBLIC_ADDRESS_BASE58_ PREFIX = 18

Monero的主网使用'18'表示主地址（这就是为什么Monero主地址以'4'开头，这是ASCII表示）。

Monero开发人员使用测试网和stagenet，它们有自己唯一的网络字节：

| 名称          | 代码值(十进制) | 前缀的ASCII值 |
| ------------- | -------------- | ------------- |
| 主网主地址    | 18 (0x12)      | 4             |
| 主网子地址    | 42 (0x2a)      | 8             |
| 测试网主地址  | 53 (0x35)      | 9             |
| 测试网子地址  | 63             | B             |
| stage网主地址 | 26             | 5             |
| stage网子地址 | 36             | 7             |

#### **5.3.3.2** 拼接而成的公钥 

公开花费密钥和公开可视密钥被拼接，并附加到网络字节来产生原始地址（除校验和之外的所有内容）。 虽然此地址仍为原始格式，但它包含所有密钥信息：这些秘钥用于产生交易以及网络元数据，以确保将交易广播给正确的网络。

#### **5.3.3.3** **校验和**

由于Monero交易是不可逆的，因此将款项发送到正确的地址至关重要！为了避免拼写错误和其他小错误，地址包含校验和。 如果发送者拼写错误或未获得完整地址，则地质和校验和就不能进行匹配，这表示输入的字符串不是一个有效地址。

这个校验和由Keccak生成的，用于哈希上一节章中收集的地址信息。 哈希摘要的前4个字节用作校验和。

**5.3.3.4** **把所有放在一起：地址** 

最后，根据Monero规范拼接网络字节，密钥和校验和：

| 索引 | 字节数 | 含义描述                                                     |
| ---- | ------ | ------------------------------------------------------------ |
| 0    | 1      | 标识monero网络和地址类型 - '18'代表主网，53代表测试网（采用base58编码，它们分别是4和9） |
| 1    | 32     | 公开花费密钥                                                 |
| 33   | 32     | 公开可视密钥                                                 |
| 64   | 4      | 校验和（截取前面65字节经过Keecak后哈希值的前4字节）          |

最后，这个69字节的输出字符串被编码为Monero 的base-58格式。 此转换将长度增加到具有95个字符的字符串，易于读写。 这里的所有都是它的！ Monero主要地址仅包含：

**[network byte + public spend key + public view key + checksum]** 

标准的样例地址: 

4BKjy1uVRTPiz4pHyaXXawb82XpzLiowSDd8rEQJGqvN6AD6kWosLQ6VJXW9sghopxXgQSh1RTd54JdvvCRsXiF41xvfeW5

下面的伪代码描述了生成公开地址的过程，使用Hs()来表示Keccak哈希函数和'||' 表示字符串拼接。

Checksum = Hs(Varint(Prefix) || public spend key || public view key)

SerializedString = Base58(Prefix || public spend key || public view key || checksum)

第7章包括用于生成自己的密钥和地址的实际Python代码！

**5.3.4** **子地址** 

Monero交易的隐私是通过三种主要结构实现的：环签名，隐型（一次性）地址和RingCT。 这些结构降低了通过分析区块链数据链接交易的风险。但是，用户必须考虑“链下”可链接性的风险（换句话说，除了区块链数据本身之外从其他来源收集的信息）。

例如，假设您的主要地址已收到来自几个不同人的付款。由于Monero的隐形地址技术，您的公开地址永远不会明确记录在交易中，因此没有人能够通过分析区块链（包括消费者）来链接这些交易。但是，如果您的发送方有二人彼此沟通并发现他们已将moneroj发送到同一地址，则完全绕过了这种密码隐私！

您可以通过生成多个子地址来避免此风险，并与每个发送方分享一个唯一的子地址。这些子地址从相同的秘钥推导而来以作为您的主地址，因此收到汇入任何子地址的资金将路由到相同钱包的余额中。然而，不同的子地址在密码学上是不可链接的，因此将moneroj发送到同一个钱包的多个人无法通过比较他们的地址列表来识别这一点。

**5.3.4.1** **创建子地址**

回想一下，每个钱包都有两个密钥对。私有可视密钥（pV0）和私有花费密钥（pS0）要保密，而公开可视密钥（PV0）和公开花费密钥（PS0）被编码到每个地址中。 如所讨论的，通过将私钥乘以椭圆曲线上的生成元（G）来生成公钥，即（PV0，PS0）=（pV0，pS0）G。（符号有问题）

您的钱包可以创建大量的子地址，每个子地址都有一个不同的索引“i”（通常从i = 1开始）。每个子地址在每个索引处都有自己的密钥集，包含唯一的私有（pVi，pSi）和公开（PVi，PSi）密钥。

为第i个子地址创建公开花费密钥的公式是：

PSi = Hs(pV0||i)G+PS0 

此过程首先将索引“i”拼接到主地址私有可视密钥（pV0），然后将拼接结果传给hash_to_scalar函数（注意：实际上，参考客户端钱包还将字符串SubAddr拼接到数据，作为哈希的常用盐）。 生成的标量乘以曲线生成元，通过椭圆曲线点加法添加到主公开花费密钥。

子地址公开花费密钥乘以主私有花费密钥，生成子地址公开可视密钥：

PVi = pV0*PSi 

子地址的公钥按照与主地址相同的约定被编码到公开地址中：

Subaddress_i = base58(network byte || PSi || PVi || checksum) 

但是，子地址的主网络字节是0x42，这就是为什么它们都以数字“8”开头的原因。

**5.3.4.2** **向子地址发送**

这种不同的识别第一个网络位是至关重要的，因为构造到子地址的交易必须稍微不同于正常情况。

构造交易时，钱包通常会生成32个随机字节作为私钥(private key)。当发送到主地址时，该随机密钥通过椭圆曲线标量乘法乘以椭圆曲线生成元产生交易公钥。但是，当发送到子地址时，私有交易密钥将乘以接收的子地址的公开花费密钥。

**5.3.4.3** **接收子地址**

由于Monero区块链的模糊性质，钱包必须扫描每个交易，以确定它是否属于所有者。

为了确定给定的输出X（具有公开交易密钥R）是否被发送到主地址，钱包基于其公开可视密钥和公开花费密钥来检查计算。 如果等式X == Hs（pV0 * R）G + PSi为真，那么该输出可以被解锁和花费！

但是，该过程与检查哪些输出属于子地址略有不同。 除了从输出中减去hash_to_scalar项以及与子地址公开花费密钥进行比较之外，计算大致相同。 如果PSi == X —Hs（pV0 * R）G为真，则钱包知道自己在其已经拥有的输出上找到了。

### 5.3.5 其他密钥派生方法 

为了增加混淆，目前在Monero中使用了至少3种不同的私钥派生方法（比特币的情况也是这样）。 这些方法在几种“密钥”派生方式各有不同：

原始（非确定性风格）：独立随机地选择私有花费密钥和私有可视密钥形成一个帐户。 除了保留每个秘钥文件的副本之外，没有好的方法来备份非确定性帐户。 由于有了更好的替代方案，不再推荐这种笨重的方法。

助记符（确定性或“Electrum”）样式：在此样式中，所有密钥都来自单个私有花费密钥，被称为种子(seed)。 通过使用Keccack-256对私有花费密钥进行哈希来生成私有可视密钥，从而生成有效的EdDSA标量。 这些帐户很容易备份，因为您只需要记下种子（通常表示为1626进制助记词）。

MyMonero样式：MyMonero钱包系列使用类似于Electrum约定的方法，但是种子短语是13个单词而不是通常的25个单词。13个单词转换为128位整数，用于派生花费和可视密钥。整数种子用Keccak-256进行哈希处理并转换为私有花费密钥。 此私有花费密钥再次使用Keccak-256进行哈希处理并转换为私有可视密钥。

您可能已经注意到MyMonero和Electrum种子样式之间存在重大差异。 MyMonero通过对随机整数进行哈希来创建私有可视密钥，而Electrum样式对私有花费密钥进行哈希。这意味着13个和25个单词种子不兼容——无法创建与MyMonero样式的帐户匹配的Electrum样式的帐户（反之亦然），因为可视密钥对将始终不同。

## 5.4  Monero隐私技术 

### 5.4.1  隐地址

第3章概念性地介绍了一次性地址（也称为隐地址）如何在不披露接收者的真实地址的情况下允许将交易发布到网络。 本节将更深入地解释一次性公钥背后的密码学。

#### 5.4.1.1 发送

CryptoNote协议根据公式X = Hs（r * PV | i）G + PS计算接收的一次性地址。 首先让我们逐步了解这些符号的含义，以及Maria在向George汇款时如何生成一次性地址。

变量r是交易私钥，它是一个256位伪随机标量。 Maria（发送者）是唯一知道这把钥匙的人; 甚至George（接收者）也不知道该随机数，它是Maria的钱包为r选择。

Maria将George的公开可视密钥(public view key)PV乘以r，然后附加(交易)输出索引i。 然后，（r * PV | i）通过hash_to_scalar函数Hs()运行。 此函数使用Keccak-256算法对其输入进行哈希处理，然后将得到的哈希模上一个素数2^255 + 27742317777372353535851937790883648493. 

上面段落计算的Hs（r * PV | i）项乘以ed25519 曲线的基点G。最后，Maria将此数加到George的公开花费密钥(public spend key)PS中，以生成最终输出X，即隐地址。

这个复杂的过程允许Maria在区块链上向George隐藏交易，由于使用一个随机生成的一次性地址，没有人能找到他。

#### 5.4.1.2 接收

由于Maria隐藏了她发送给George的moneroj（被George都不知道的一个交易私钥所掩盖），你可能想知道他怎么能在区块链上找到它！

如第3章所述，George必须扫描区块链以查找属于他的交易输出。 该过程与Maria用于生成地址的方法非常相似。

George从区块链中获取公开交易密钥R，并将其乘以其私人可视密钥（private view key）pV。 按照与Maria类似的步骤，George附加交易输出索引i，然后将hash_to_scalar函数应用于（pV * R | i）。 然后他将结果乘以G并添加他自己的公开花费密钥(public spend key)PS。 如果此值与交易输出匹配，则该笔交易属于他。

换句话说，George的钱包扫描区块链中的每个交易，以识别X = Hs（pV * R | i）G + PS的输出。

### 5.4.2 环机密交易

环形机密交易（RingCT）模糊了交易中发送的moneroj数量。 RingCT于2017年1月实施，并在2017年9月之后的所有交易中成为强制性要求。

只有将新铸造的moneroj作为coinbase奖励的交易中才有公开可见的数额，它没有被RingCT所掩盖。 这是一项审计功能，允许任何网络参与者计算并准确验证已生成多少moneroj。 在公开发行门罗币之后，这些交易在进一步使用之前转换为RingCT输出。

所有非coinbase交易都使用RingCT来加密交易数额。 每个交易的数额都以两种不同的方式加密，这两种方式都包含在消息中。

首先，通过从接收者地址中的公共信息导出的密钥对数额进行加密。 此版本记录在ecdhInfo字段中，只能由接收方使用交易共享密钥解密和读取。

其次，交易的数额被整合在一个Pedersen 承诺中，这允许其他Monero用户自身验证这些交易的有效性。没有人可以从Pedersen承诺中找出交易数额，但是任何人都可以检查结果，在数学上验证收支平衡。 这阻止了任何尝试伪造moneroj的交易。

关于RingCT的验证有两个关键的方面：

1. 发送者使用范围证明以可验证的方式证明交易的所有输出含有正的数额。范围证明表明，将masked number 生成为2的正幂的和，不需要披露它们的幂次。如果没有范围证明，一个拥有5XMR的恶意用户可以创建一个交易，它包含+13XMR和-8XMR的一对输出。
2. 发送者还证明交易的输入和输出是保持平衡的，考虑到环签名包含托儿(decoys)以防止验证方知道输入资金的真实来源，这是有难度的！ 同态Pederson承诺使发送方能够证明可能的一个输入与输出之间的差为零，在这个过程中不需要批露交易的金额。

为了进行简单的类比，请考虑以下示例方程式。 与隐藏交易金额一样，您可以在不知道A的值的情况下验证每个方程式是否有效。

​	A = 我们的输出, 没有人知道
​	5A + 1A + 4A = 10A  真!  通过验证, 不知道 A 

​	6A + 4A + 2A = 14A  假!  未通过验证, 拒绝! 

### **5.4.3 环签名**

Monero利用环签名技术来保护每笔交易的发送者的隐私。 环签名是一种密码签名，它允许一个合法参与者代表群组成员签署消息。合法签名者持有的私钥与其他成员的公钥信息混合以产生单个签名。任何人都可以根据公钥验证签名的消息，以验证其中一个环成员发起了签名，但是无法确定哪个成员签名了消息。

在门罗币中，消息是由环签名授权的交易。 实际花费的交易输出是真正的签名者，其他输出（来自过去的交易）的公钥作为托儿签名者混杂其中。 实际的签名者和托儿签名者在数学上是同等有效的；最终的环签名结果是无法以密码学的方式检查来确定哪个成员主动发起了签名。 因此，任何外部人员（包括接收方）都无法确定交易中引用的哪些输出实际被花费了。

 每个环签名都会产生一个单独的密钥镜像，该密钥镜像是从实际花费的输出中得出的。 这是一个密码学安全的过程：每个输出对应一个单一的密钥镜像，并且产生密钥镜像不会披露环中真正的签名者。

当交易输出的所有者在将其用于新交易时，Monero网络将存储由环签名生成的密钥镜像。由于网络无法识别哪些输出是被花费的，因此它会跟踪花费的密钥镜像！ 如果所有者尝试欺诈性地再次花费该输出，则会生成相同的密钥镜像，因此Monero网络知道拒绝交易。

让我们深入研究生成环签名的实际数学方法。 在整个示例中，假设HS是一个散列函数，其返回标量（位于适当的域中），HP是一个散列函数，其返回点（位于适当的曲线群中）。 为避免复杂化，我们故意避免形式化定义这些定义域和陪域(codomain)。 我们令G是各方都知道的不动点。

您用环签名对交易消息M进行签名。 门罗币目前每个环签名需要11个环成员，但是让我们考虑一个简化示例，其中包含3个环成员。 您拥有要花费的交易输出的密钥对（公钥和私钥），并选择其他两个交易输出（及其公钥）作为托儿。自然地，环成员的索引应该随机化，因为如果真正的签名者始终在插槽1，则将绕过密码匿名性。对于具有三个环成员的简化示例，假设您的钱包已随机选择以将真实资金来源放入插槽2。

您从区块链中检索了托儿的公开输出密钥（P1和P3），并且您持有正在花费的输出的私钥（p2）和公钥（P2 = p2G）。 首先选择一个随机数u，然后将其丢弃。 首先，您从您为密钥选择的索引开始创建承诺：

c3 = Hs(M, uG, uHp(P2)) 

为了形成其余承诺，您还可以选择以后将需要的随机数s3和s1：

c1 = Hs(M,s3G + c3P3 , s3Hp(P3) + c3p2Hp(p2)) 

请注意，您在此处包括多个信息片段：您从区块链中选出的公钥P3，您提出的随机数s_3，先前的承诺c3以及由您自己的密钥形成的值p2 Hp（P2）。 您继续：

c2 = Hs(M, s1G + c1P1, s1Hp(P1) + c1p2Hp(P2)) 

但是您还没有完成！要隐藏真实密钥所在的位置，您可以巧妙地定义s2 = u − c2 p2。 您发送到区块链和整个世界的签名包含多个数量：（c1，s1，s2，s2，J），其中J = p2Hp（P2）是每个承诺中使用的密钥镜像。 我们在这里重命名它是为了突出这样一个事实，即公众不知道用来构成它的部分。

这就是为什么这样做很巧妙地原因：通过设置s2 = u − c2 p2，您可以重新排列得到u = s2 + c2p2。 这意味着公众会看到您做出的第一个承诺c3如下：

c3 = Hs(M, s2G + c2P2, s2Hp(P2) + c2p2Hp(P2)) 

这看起来与其他承诺完全一样！ 尽管您从未广播过u，但您可以使用它巧妙地使每个承诺在观察者眼中看起来都一样。 这就是环签名的力量。没有人可以确定哪个承诺隐藏了您的真正密钥，但是每个人都可以从数学上验证它们，即：

1. 发送者知道多个公钥对应的私钥中的之一
2. 正确计算密钥镜像

请注意，密钥镜像J = p2Hp（P2）是根据真实输出的密钥对唯一计算得出的，没有任何随机数或环成员的公钥。 因此，任何欺诈尝试二次花费相同的交易输出都将生成一模一样的密钥镜像。由于Monero网络追踪已经使用了密钥镜像，因此很容易检测和拒绝再次使用输出的任何尝试。

请注意，上面的Back-style LSAG环签名示例是出于教育目的提供的，不应用作生产实现的参考文档。

### 5.4.4  扩展阅读

如果您想进一步了解这些技术背后的计算，请查阅Zero to Monero，一次技术性很强的数学之旅，也可以免费获得社区资助的PDF。

## 5.5 Monero区块链

到目前为止，您已经知道了作为分布式公共账本的区块链的重要性和实用性。 这些区块被结构化的且有序排序到一个不可篡改的仅可增加的数据库中，其安全性是通过防范任意篡改或欺骗的密码工具进行保护。Monero区块链是独特的，我们将在本节中讨论其技术和规范。

### 5.5.1  高速内存映射数据库

Monero使用高速内存映射数据库（LMDB）系统存储其区块链。LMDB是一个以键值存储的形式提供高性能嵌入式事务数据库的软件库。这意味着它非常高效并且易于搜索。

LMDB用C++编写的，其API绑定了多种编程语言，它由Symas Corporation开发。 以下是一些LMDB功能：

- 任意键/数据对存储为字节数组
- 基于范围的搜索功能
- 支持单个键，多个数据项
- 在数据库末尾追加记录的高级方法，这极大地提高写入性能，优于其他类似的存储。

### 5.5.2  区块结构

CryptoNote标准定义了在区块内和区块链上存储和描述数据的规范。区块结构包含三个主要部分：

- 区块头
- 基础交易
- 交易标识符列表(区块中交易的哈希)

#### 5.5.2.1 区块头

每个区块始于包含关键元数据的区块头。“major_version”字段定义了区块头解析规则，因此可以正确解释区块头。“minor_version”字段定义了与解析主区块头不相关的解释细节。

纵使minor_version字段是未知的，解析特定major_version的区块头也是安全的。解析使用未知的major_version的区块头是有风险的，因为区块头的内容可能会被错误解释。

| 字段          | 数据类型 | 含义                       |
| ------------- | -------- | -------------------------- |
| major_version | varint   | 区块头的主版本号           |
| minor_version | varint   | 区块头的次版本号           |
| timestamp     | varint   | 区块创建时间（Unix时间戳） |
| prev_id       | hash     | 前一个区块的哈希           |
| nonce         | 4bytes   | 用在网络共识算法的任意值   |

#### 5.5.2.2 基础交易

每个有效的区块包含一个基础交易，该交易将其Coinbase奖励发放给矿工。基础交易必须遵循Monero的货币发行规则，并包括区块高度字段。

#### 5.5.2.3 交易标识符列表

| 字段        | 数据类型 | 含义                        |
| ----------- | -------- | --------------------------- |
| version     | varint   | 交易格式版本                |
| unlock_time | varint   | Unix时间戳                  |
| input_num   | varint   | 输入数量。基础交易该值总是1 |
| input_type  | byte     | 基础交易总是0xff            |
| height      | varint   | 包含该交易的区块高度        |
| output_num  | varint   | 输出的数量                  |
| outputs     | array    | 输出列表                    |

基础交易之后是交易标识符列表。这些标识符是通过获取交易体的Keccak哈希计算得来的。列表始于标识符的数量，后面是标识符本身（如果区块不是空的）。

#### 5.5.2.4 计算区块标识符

一个区块的标识符是通过使用Keccak-256对以下数据进行哈希运算而产生的：

- 区块头大小
- 区块头
- Merkle根哈希
- 交易数量（varint类型）

Merkle根哈希将区块体中引用的交易“附加”到区块头：一旦Merkle根哈希固定，交易就不能被修改。此安全功能可使区块链免受篡改或任何类型的追溯性修改。

### **5.5.3   **挖矿经济

第2章和第4章在概念上提到了区块奖励和交易费用。现在，您将真正了解区块大小、奖励以及它们与交易收费之间关系的复杂性。

#### 5.5.3.1 挖矿coinbase奖励

正如第四章所讨论的，所有的Moneroj起源于对成功完成区块的矿工的奖励。这种Coinbase支付的多少取决于当前的供应量(A)和原子单位的初始数量(S=2^64-1)。原子单位是目前Monero网络识别的最小单位(1x10^-12 xmr)。

基础奖励 = 2 * ((S - A) * 2-20 * 10-12) 

Monero有一个尾部发行(tail emission )，这是一个小的固定基础奖励，在大部分供应被开采后将继续。Monero的最低基础奖励是每个区块0.6 XMR，因此矿工永远不必仅靠交易费维生。

#### 5.5.3.2 动态区块大小

Monero具有动态区块大小，这区别与许多使用静态（固定）区块大小的密码学货币，因此它可以随着网络的增长进行连续调整。 例如，比特币最初的1 MB大小的固定区块引发了比特币的扩容问题，通过限制每个区块中可能包含的交易数量（因此限制了网络的总交易量）解决这个问题。 在2017年，这一瓶颈导致在那段时期产生极高的费用和交易的延迟处理。因此比特币社区提出了五花八门的解决方案，导致了一段时间的激烈辩论。

为了避免这些问题，门罗币采用了动态区块大小机制，该机制允许矿工使用更大的区块来容纳增加的流量。但是，如果完全不限制区块大小，则Monero网络可能容易受到垃圾交易攻击，即，许多小交易旨在通过使区块链扩张过快反而耗尽网络和存储资源。

为了防止区块大小过度增长，Monero挖矿协议包括一个惩罚函数，该函数会减少超大区块的基础coinbase奖励。 最初的CryptoNote作者们纳入该共识规则，以限制区块大小扩展的速率并避免快速的区块链膨胀。

如果开采的区块的大小（B）大于最后100个区块（MN）的中值大小，则将扣除部分基础奖励，根据公式：

Penalty = BaseReward * ((B / MN) - 1)2 

对于任何区块大小不超过300 kB的区块，矿工将获得全额奖励； 对于更大的区块，惩罚函数会“发挥作用”。 最大的区块大小为2 * MN，此时将扣除整个coinbase奖励。

#### 5.5.3.3 交易费

当交易量低且区块大小较小时，矿工将获得全部的coinbase奖励，并且交易费用极低。

但是，请设想另一种情况：如果最后100个区块的大小的中值增长到大于免罚区块大小（300 kB），会发生什么？ 那么，该动态收费算法出场了！

交易费用是根据交易的权重（以kB为单位）计算的。 较大（“较重”）交易会产生更高的交易费用。由于考虑Monero生态系统的多个因素以及交易的优先级（发送者可以通过附加更大的费用来激励矿工快速地纳入一笔紧急交易），因此Monero的动态交易费用计算非常复杂。计算即将到来区块的交易费用必须是有竞争力的，根据以下公式：

Fee per kB = (R/R0) * (M0/M) * F0 * (60/300) * 4 

- R 是基础奖励
- R0 是参考基础奖励 (10 XMR)
- M 是区块大小限制
- M0 是最小的区块大小限制(300 kB)
- F0 是 0.002 XMR
- 60/300 是调节因子，用来增加免罚区块的大小限制(在2017年免罚区块大小从60 kB 调整到 300 kB)
- 4 是调节因子，用来调节默认交易费用倍数（最低费用级别使用x1的乘数，而正常的优先级交易使用x4）

因此，交易费用考虑了区块大小的中值相对于最小区块大小增加。 例如，一个600 kB的区块（最小区块大小的两倍）可将交易费用减少一半。

理想情况下，提高Monero的汇率和使用量将导致绝对交易费用的减少（即，按XMR计）。 这种费用减免机制在极端价格上涨期间的有效性较低，而极端价格上涨的幅度远远大于交易量（和这样区块大小）的增长。

动态交易费用算法旨在中位数区块大小始终高于300 kB时发挥作用。 尽管该系统旨在解决价格上涨的问题，但使用情况与价格并非完全相关，因此这是一种不完善的指标。

### 5.5.4 Bulletproofs

Bulletproofs 是一个新的功能，其显著降低了交易大小，它又反过来降低了每笔交易总的交易费用。Monero的交易大小是相当大的（一般>12kB）,因此Bulletproofs 是期待已久的改进。

为了防止滥用和垃圾交易，Monero的隐私功能需要在交易验证期间进行多次复杂的“测试”。这包括验证隐藏的金额，检查交易费用以及确认有没有双花发生。

当操作创建的值超出可以表示的范围时，大多数开发人员都遇到“溢出”错误。不幸的是，“无限”是电子学的抽象概念，这将遇到了许多障碍。

由于RingCT隐藏了交易金额，因此需要进行复杂的计算来验证输入和输出是否相等。承诺的代数性质对于启用隐藏交易非常有价值，其有效性可以由任何参与者确认。

但是，确保每个金额都是一个不会引起溢出的正值也很重要。通过使用范围证明，任何人可以验证承诺表示的金额在指定范围内，而又不披露任何其他信息。每个范围证明都需要约7 kB，因此它们占了交易大小的大部分。大多数交易具有两个输出（目的地址和找零地址）至少需要〜12 kB。

`Bulletproofs`运用一些巧妙的数学技巧，以一种更有效的机制来构建范围证明。这样可以将单个范围证明的大小减小到〜2 kB！

在`Bulletproofs`之前，有多个输出的交易需要多个单独的范围证明。因此，交易的大小同交易的输出数量呈线性变化（例如1个输出= 7 kB，2个输出= 14 kB）。使用Bulletproofs后，交易的大小随交易的输出呈对数变化（例如1个输出= 2 kB，2个输出= 2.5 kB）。

通过减小每个范围证明的大小，并允许它们以更有效的方式进行组合， bulletproofs 降低了交易大小，又降低了交易费用。 2018年10月，Monero v0.13.0网络升级启用了Bulletproofs这个功能，这是一项可选功能，它将在后续升级中成为必需功能。

 