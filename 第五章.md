#  5 深入Monero和密码学 

在计算机诞生很久以前，数学和密码一直是通信和信息交换的中心。自从凯撒时代以来，简单的密码就已经出现了，现代密码学诞生于世界大战期间，用于加密重要和机密的信息。最初，政府和军方资助密码学研究以求找到保护国家机密的协议。

现在，密码学不再局限于间谍和军队；它是互联网时代通信和安全的中坚力量，受到全球来自学术界和工业界研究者的广泛研究。

今天，密码学是一个无处不在的幕后工具，它使安全、管理、通信和许多改善我们日常生活的连接成为可能。例如，考虑一下安全套接字层(SSL，不赞成使用TSL)的发明，它基于对内容进行密码签名。医院、银行、政府和企业都使用密码保护您的数据。

本章讨论如何将密码工具应用到去中心化的金融数据库中，从而催生出密码货币，尤其是Monero。

## 5.1 数学基础

下面简要介绍密码学中核心的几个数学原理。

### 5.1.1 **欧几里德除法** **(A/B)** 

将任意数字A除以另一个B（记为A/B或A÷B）返回一个答案，该答案可以写成带余数的商，也可以单独写成十进制。

通常:

A/B = q 余数 r

例如:

12/4=3，余数为0，可以用十进制形式记为3.0

13/4=3，余数为1，可用十进制形式记为3.25

27/5=5，余数为2，可以用十进制形式记为5.4

### 5.1.2 **素数**

素数是除“1”和它本身之外，不能被其他任何整数整除的数。例如：

20不是素数，因为它可以被2, 4, 5和10整除，然后得到整数。

例如. 20 ÷ 4 = 5

 \- 或 - 

20 ÷ 10 = 2 

7是素数，因为任何整数整除7都不会得到整数。

例如. 7 ÷ 3 = 2.3333 

一些素数的例子包括3, 5, 7, 11, 13, 97, 223, 997, 3413, 4421, 17837, 145601, 428567, 1171967, 甚至更大的数字像20747222467734852078216952221076085874809964747 21117292752992589912196684750549658310084416732550077 ，或双素数2,996,863,034,895×2^1,290,000±1，每个数超过350,000位!

### 5.1.3 **模运算** 

模运算是指数字折回到特定整数内。最常见的例子是12小时制，如果你在晚上11点之后熬夜5小时，你就不会见到下午16点的时钟！ 相反，在午夜，时间折回到零（所以在晚上11点过后5小时是第二天凌晨4点）。

给出任意两个正数，A（被除数）和B（除数），

A模B = A / B的余数r。

在时钟例子中，晚上11点后再过熬夜5小时可以表示为：

（11:00 PM + 5小时）mod 12 = ... = 16:00 mod 12

= 4:00（AM）

### 5.1.4 **整数表示** 

整数可以用许多不同的编码来表示，其中一些在计算机科学中经常遇到。

大多数人都非常熟悉以10为基数的“十进制”系统，它代表使用10个字符的数字：

0,1,2,3,4,5,6,7,8,9. 

对于基数为16的集合，“十六进制”编码增加了6个额外字符：0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f。

用十进制记为11719682的整数可以表示为用16进制的B2D402。 注意，更大的字符集需要较少的数字（较短的字符串）来表示相同的数字。

计算机按二进制“思考”，仅使用字符“0”和“1”。这称为二进制，数字11719682（10进制）将表示为101100101101010000000010。

Monero 基于58进制打印最终地址和密钥，它使用阿拉伯数字和大多数拉丁字符集（大写和小写）。 它类似于另一种称为Base64的方案，但是它已被修改以避免在打印时看起来有歧义的数字和字母。Monero使用这种格式，完全是为了方便人类用户，这些用户通常必须手动读取或抄写长地址。

58进制数是：

123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz

注意：零（0）和字母I（大写的i），O（大写的o）和l（小写的L）在这个Base58字母表中不存在，因为它们彼此的二义性。

### 5.1.5椭圆曲线

#### 5.1.5.1 **一般介绍** 

椭圆曲线定义为满足方程的二维(x, y)点集:

y2=x3+ax+b.

例如，固定系数a=2，b=3，等式变为

y2=x3+2x+3.

很多对点满足等式，如:

x = 3和y = 6

x = 3 和 y = -6

 x = -1 和y = 0.

#### 5.1.5.2Ed25519 Twisted Edwards 

Monero使用一条特殊的Twisted Edwards 椭圆曲线进行密码运算，Ed25519, 它是Montgomery曲线Curve25519的双有理等价。 Ed25519曲线可以代数表示为

\- x2 + y2 = 1 − (121665/121666) x2*y2. 

回想一下我们一般的椭圆曲线方程，这个Twisted Edwards是一个特例，它使用的参数是:

a = -1 和 b = 121665/121666. 

最近，NIST背书的PRNG（Pseudo-random Number Generator算法）存在缺陷变得很显然，并且包含潜在的后门。 由于NIST4标准算法最近出现了问题，因此选择Twisted Edwards曲线来解决密码学界所关注的许多问题。

从更广泛的角度来看，NIST选择的曲线也得到了NSA的秘密支持。密码学家和密码货币社区对这些支持持怀疑态度，因为在过去的事件中，NSA利用它们对NIST的权力削弱了后者提出的算法。

Twisted Edwards曲线Ed25519不受任何专利的约束，其背后的团队开发并改进了基本的密码算法，并考虑了效率。目前认为该曲线是安全的。

#### 5.1.5.3 **椭圆运算** 

椭圆曲线点的加法和标量乘法是椭圆曲线密码方案的基本操作。在深入Monero的计算机制之前，对这些概念有一个基本的了解是有帮助的。

椭圆曲线点的加法运算不同于一般的加法运算。要对椭圆曲线上的两个点同时做加法，必须找到这两个点之间的直线，然后找到曲线与该线相交的点。然后这个点关于x轴上对称点为最终点。

当向自身相加一个点时，称为倍点运算(point doubling)，您必须找到起点的切线，找到切线与曲线的交点。然后这个点在x轴上对称点为最终点。

标量乘法(scalar multiplication)使用曲线上的一个点和整数。要用整数S乘以一个点P，该点和自身相加S次。很多密码方案，例如Monero采用的方案，使用了椭圆曲线上的一个公共基点作为生成元点来生成对应私钥的公钥。

当曲线生成元点多次和自身相加时，生成的点不能用于确定发生了多少次运算。这个问题常称为椭圆曲线离散对数问题。这种标量乘法被认为是一个单向函数，因为求逆运算非常困难。